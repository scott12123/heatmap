<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Signal Heatmap</title>
  <link rel="stylesheet" href="/leaflet/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="/leaflet/leaflet.js"></script>
  <script src="/leaflet/leaflet-heat.js"></script>
  <script>
  fetch('/data')
    .then(r => r.json())
    .then(raw => {
      const items = Array.isArray(raw) ? raw : [raw];
      // Filter out entries without valid latitude and longitude
      const points = items
        .filter(i => i.latitude !== undefined && i.longitude !== undefined) // Ensure lat/lng exist
        .map(i => [
          parseFloat(i.latitude),
          parseFloat(i.longitude),
          i.scan_result && i.scan_result.signal_quality
            ? i.scan_result.signal_quality / 100
            : 0.5 // Default intensity if signal_quality is missing
        ]);

      const map = L.map('map').setView([0, 0], 2);

      // Define the default map layer
      const defaultLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      });

      // Define the satellite map layer
      const satelliteLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
        attribution: '© Google Maps',
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
      });

      // Add the default layer to the map
      defaultLayer.addTo(map);

      // Add the heatmap layer
      if (points.length) {
        const bounds = L.latLngBounds(points.map(point => [point[0], point[1]]));
        map.fitBounds(bounds);

        const heatLayer = L.heatLayer(points, {
          radius: 35,
          gradient: {
            0.0: 'blue',   // 0% intensity
            0.3: 'green',  // 30% intensity
            0.6: 'yellow', // 60% intensity
            1.0: 'red'     // 100% intensity
          }
        }).addTo(map);

        // Add layer control to toggle between default and satellite views
        L.control.layers({
          'Default View': defaultLayer,
          'Satellite View': satelliteLayer
        }).addTo(map);

        // Create a popup for displaying the signal strength of the closest point
        const popup = L.popup();
        const radiusThreshold = 50; // Define the radius threshold (in meters)

        // Function to find the closest point to the mouse location
        function findClosestPoint(latlng) {
          let closestPoint = null;
          let minDistance = Infinity;

          points.forEach(point => {
            const distance = map.distance(latlng, L.latLng(point[0], point[1]));
            if (distance < minDistance) {
              minDistance = distance;
              closestPoint = point;
            }
          });

          return { closestPoint, minDistance };
        }

        // Update the popup dynamically on mousemove
        map.on('mousemove', (e) => {
          const { closestPoint, minDistance } = findClosestPoint(e.latlng);
          if (closestPoint && minDistance <= radiusThreshold) {
            const signalStrength = (closestPoint[2] * 100).toFixed(2); // Convert intensity back to percentage
            popup
              .setLatLng(e.latlng) // Set the popup position to the mouse location
              .setContent(`Signal Strength: ${signalStrength}%`) // Update the content
              .openOn(map); // Open the popup on the map
          } else {
            map.closePopup(popup); // Close the popup if no point is within the radius
          }
        });
      } else {
        console.error('No valid points to display on the map.');
      }
    })
    .catch(err => console.error('Failed to load data', err));
</script>
</body>
</html>
